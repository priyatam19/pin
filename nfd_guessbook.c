// --- Auto-generated by fd_to_nfd.py: Normalized Fuzz Driver ---
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include "app/src/db.hpp"
#include "app/src/tpl/filter.hpp"
#include "crow/http_request.h"
#include "crow/query_string.h"

// Database setup with a dummy row
Db* initialize_db() {
    Db* db = new Db();
    if (!db->db) {
        fprintf(stderr, "Cannot open database\n");
        delete db;
        return nullptr;
    }

    // Insert a dummy row so the query has something to work with
    DbStatement stmt = db->prepare("INSERT INTO guests (name, email, message) VALUES (?, ?, ?)");
    if (!stmt.stmt) {
        fprintf(stderr, "Cannot prepare insert statement\n");
        delete db;
        return nullptr;
    }

    sqlite3_bind_text(stmt.stmt, 1, "Dummy", 5, SQLITE_STATIC);
    sqlite3_bind_text(stmt.stmt, 2, "dummy@example.com", 17, SQLITE_STATIC);
    sqlite3_bind_text(stmt.stmt, 3, "Dummy message", 13, SQLITE_STATIC);

    if (sqlite3_step(stmt.stmt) != SQLITE_DONE) {
        fprintf(stderr, "Insert failed: %s\n", sqlite3_errmsg(db->db));
        delete db;
        return nullptr;
    }

    return db;
}

// Simulate the /filter route
void process_filter_route(Db* db, const char* safe_buf, size_t input_len) {
    // Fixed where param to match the dummy row, fuzzed order_by param
    std::string query_str = "where[name]=Dummy"; // Match the inserted row
    if (input_len > 0) {
        query_str += "&order_by=";
        query_str.append(safe_buf, input_len);
    }

    printf("Query string: %s\n", query_str.c_str());

    // Mock the request
    crow::request req;
    req.url_params = crow::query_string(query_str, false);

    // Let filter.cpp process the request
    tpl::Filter filter(*db, req.url_params.get_dict("where"), req.url_params.get_dict("order_by"));
    crow::response resp = filter.render();

    printf("Response code: %d\n", resp.code);
    printf("Response body: %s\n", resp.body.c_str());
}

int NFD(const uint8_t *safe_buf, size_t input_len) {
        // [fd_to_nfd] Make a safe, null-terminated buffer for string ops
        size_t safe_len = (input_len < BUFFER_SIZE - 1) ? input_len : (BUFFER_SIZE - 1);
        char safe_buf[BUFFER_SIZE];
        memcpy(safe_buf, safe_buf, safe_len);
        safe_buf[safe_len] = '\0';
        
    printf("Testing guestbook v0.8.1\n");

    // Set up the database
    Db* db = initialize_db();
    if (!db) {
        return 1;
    }

    // Buffer for AFL++ safe_buf
    size_t input_len = fread(safe_buf, 1, sizeof(safe_buf), stdin);
    if (input_len <= 0) {
        printf("No safe_buf from AFL++\n");
        delete db;
        return 1;
    }

    // Feed the entire fuzzed safe_buf to order_by
    process_filter_route(db, (const char*)safe_buf, input_len);

    delete db;
    
        // [fd_to_nfd] Cleanup persistent state after each call
        free_entries();
        current_id = 1;
    
    return 0;
}