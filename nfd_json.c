// --- Auto-generated by fd_to_nfd.py: Normalized Fuzz Driver ---
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "cJSON.h"

#define BUFFER_SIZE 1024

#define PARSER_VERSION_MAJOR 0
#define PARSER_VERSION_MINOR 1
#define PARSER_VERSION_PATCH 0

typedef struct Entry {
    int id;
    cJSON *json;
    struct Entry *next;
} Entry;

Entry *head = NULL;
int current_id = 1;

const char* parser_version(void)
{
    static char version[15];
    sprintf(version, "%i.%i.%i", PARSER_VERSION_MAJOR, PARSER_VERSION_MINOR, PARSER_VERSION_PATCH);
    return version;
}

void add_entry(int id, cJSON *json) {
    Entry *new_entry = (Entry *)malloc(sizeof(Entry));
    if (!new_entry) return;
    new_entry->id = id;
    new_entry->json = json;
    new_entry->next = head;
    head = new_entry;
}

cJSON *find_entry(int id) {
    Entry *current = head;
    while (current != NULL) {
        if (current->id == id) {
            return current->json;
        }
        current = current->next;
    }
    return NULL;
}

char *process_command(const char *command) {
    if (strncmp(command, "MOD", 3) == 0) {
        int id;
        char field[6], new_value[16];
        if (sscanf(command, "MOD %d %5[^,], %15s", &id, field, new_value) != 3) {
            return strdup("{\"error\": \"Invalid MOD format. Expected: MOD <id> <make, model, or year>, <new_value>\"}");
        }
        cJSON *json = find_entry(id);
        if (!json) {
            return strdup("{\"error\": \"ID not found\"}");
        }
        if (strcmp(field, "make") == 0 || strcmp(field, "model") == 0) {
            cJSON *new_string = cJSON_CreateString(new_value);
            new_string->string = strdup(new_value);
            if (!new_string) {
                return strdup("{\"error\": \"Failed to create new value\"}");
            }
            if (!cJSON_ReplaceItemInObject(json, field, new_string)) {
                cJSON_Delete(new_string);
                return strdup("{\"error\": \"Failed to replace value\"}");
            }
        }
        else if (strcmp(field, "year") == 0) {
            if (strlen(new_value) > 4) {
                return strdup("{\"error\": \"Year must be at most 4 digits\"}");
            }
            char *endptr;
            int year = strtol(new_value, &endptr, 10);
            if (*endptr != '\0') {
                return strdup("{\"error\": \"Year must be a numeric value\"}");
            }
            cJSON *new_number = cJSON_CreateNumber(year);
            if (!new_number) {
                return strdup("{\"error\": \"Failed to create year value\"}");
            }
            cJSON_DeleteItemFromObject(json, "year");
            cJSON_AddItemToObject(json, "year", new_number);
        }
        else {
            return strdup("{\"error\": \"Invalid field. Only 'make', 'model', or 'year' can be modified\"}");
        }
        char *updated_json_string = cJSON_PrintUnformatted(json);
        return updated_json_string;
    }
    if (strncmp(command, "ADD", 3) == 0) {
        char make[16], model[16], year_str[5];
        int parsed = sscanf(command, "ADD %15[^,], %15[^,], %4s", make, model, year_str);
        if (parsed != 3) {
            return strdup("{\"error\": \"Invalid ADD format. Expected: ADD <make>, <model>, <year>\"}");
        }
        if (strlen(year_str) > 4) {
            return strdup("{\"error\": \"Year must be at most 4 digits\"}");
        }
        char *endptr;
        int year = strtol(year_str, &endptr, 10);
        if (*endptr != '\0') {
            return strdup("{\"error\": \"Year must be a numeric value\"}");
        }
        cJSON *json = cJSON_CreateObject();
        cJSON_AddStringToObject(json, "make", make);
        cJSON_AddStringToObject(json, "model", model);
        cJSON_AddNumberToObject(json, "year", year);
        int id = current_id++;
        add_entry(id, json);
        cJSON *response = cJSON_CreateObject();
        cJSON_AddNumberToObject(response, "id", id);
        char *response_string = cJSON_PrintUnformatted(response);
        cJSON_Delete(response);
        return response_string;
    } else if (strncmp(command, "GET id", 6) == 0) {
        int id;
        if (sscanf(command, "GET id %d", &id) != 1) {
            return strdup("{\"error\": \"Invalid GET id format. Expected: GET id <id>\"}");
        }
        cJSON *json = find_entry(id);
        if (json) {
            return cJSON_PrintUnformatted(json);
        } else {
            return strdup("{\"error\": \"ID not found\"}");
        }
    } else if (strncmp(command, "EXIT", 4) == 0) {
        return strdup("EXIT");
    }
    return strdup("{\"error\": \"Invalid command\"}");
}

void free_entries(void) {
    Entry *cur = head;
    while (cur != NULL) {
        Entry *next = cur->next;
        if (cur->json)
            cJSON_Delete(cur->json);
        free(cur);
        cur = next;
    }
    head = NULL;
}

int NFD(const uint8_t *safe_buf, size_t input_len) {
        // [fd_to_nfd] Make a safe, null-terminated buffer for string ops
        size_t safe_len = (input_len < BUFFER_SIZE - 1) ? input_len : (BUFFER_SIZE - 1);
        char safe_buf[BUFFER_SIZE];
        memcpy(safe_buf, safe_buf, safe_len);
        safe_buf[safe_len] = '\0';
        
#ifdef __AFL_HAVE_MANUAL_CONTROL
    __AFL_INIT();
#endif
    while (__AFL_LOOP(10000)) {
    // Process safe_buf buffer here using safe_buf/input_len


        free(input_copy);

        free_entries();

        current_id = 1;
    }
    
        // [fd_to_nfd] Cleanup persistent state after each call
        free_entries();
        current_id = 1;
    
    return 0;
}